<html>

<head>
    <title>Pelumoottori<SIC> </title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix.js"               ></script>
<script type="text/javascript" src="webglutils.js"             ></script>

<script type="text/javascript" src="Renderer.js"               ></script>
<script type="text/javascript" src="Shader.js"                 ></script>
<script type="text/javascript" src="Inputs.js"                 ></script>
<script type="text/javascript" src="Scene.js"                  ></script>

<script type="text/javascript" src="Material.js"               ></script>
<script type="text/javascript" src="Texture.js"                ></script>

<script type="text/javascript" src="Buffer.js"                 ></script>
<script type="text/javascript" src="Model.js"                   ></script>
<script type="text/javascript" src="Mesh.js"                   ></script>
<script type="text/javascript" src="Light.js"                  ></script>


<script type="text/javascript" src="Guiobject.js"              ></script>
<script type="text/javascript" src="Entity.js"                 ></script>
<script type="text/javascript" src="Camera.js"                 ></script>
<script type="text/javascript" src="parser/old/Importer.js"        ></script>
<script type="text/javascript" src="parser/old/parser_Geometry.js" ></script>
<script type="text/javascript" src="parser/old/Filereader.js"      ></script>



<script type="text/javascript" src="parser/Parserobjects.js"         ></script>
<script type="text/javascript" src="parser/GeneralPurposeParser.js"  ></script>

<script type="text/javascript" src="math/Angles.js"            ></script>
<script type="text/javascript" src="math/Vector2.js"           ></script>
<script type="text/javascript" src="math/Vector3.js"           ></script>
<script type="text/javascript" src="math/Matrix33.js"          ></script>
<script type="text/javascript" src="math/Matrix44.js"          ></script>
<script type="text/javascript" src="math/MatrixGL.js"          ></script>
<script type="text/javascript" src="math/Orientation.js"       ></script>
<script type="text/javascript" src="math/Interpolator.js"       ></script>

<script type="text/javascript" src="Assetmanager.js"      ></script>

<script type="text/javascript" src="misc/Process.js"           ></script>

<script type="text/javascript" src="testCube.js"               ></script>

   









<script id="vertex_Shader" type="x-shader/x-vertex">
    
    // Transformation marices
    uniform mat4 worldViewMatrix;         
    uniform mat4 projMatrix;
    uniform mat4 worldMatrix;
   
    // Declare the light rack
    uniform vec3   lights[12];   // X,Y,Z @ world space  
    uniform vec3  lColors[12];   // Red, Green, Blue
    uniform vec3   lAtten[12];   // Constant term, Linear term, Quadratic term
    
   
   // Haxlight
    uniform vec4 light1;
    
    
    // Vertex attributes
    attribute vec3    vertexPos;
    attribute vec3 vertexNormal;
    attribute vec2     vertexUV;
    
    
    // Parameters for pixel shader
    varying   vec4  fragmentPos;
    varying   vec2  fragmentUV;
    varying   vec4  fragmentNormal;
    
    varying   vec4  vLight1;
    varying   vec4  vLight2;            // Obsolete very soon
    
    
    void main(void) 
    {
        fragmentUV     = vertexUV;
        fragmentNormal = normalize( worldMatrix * vec4( vertexNormal , 0.0 ) );
        fragmentPos    = worldMatrix * vec4(    vertexPos , 1.0 );                   // Needs to be taken from model space to world space.
        
             vLight1   = vec4( -64.297035, -34.088657, -127.10157, 1.0 );                                    
             vLight2   = vec4( -64.297035,   0.088657,  130.10157, 1.0 );                                    
        
        gl_Position    = projMatrix * worldViewMatrix * vec4(vertexPos, 1.0);
    }
    
</script>

   
<script id="pixel_Shader" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D     texSampler;
  
    varying vec4         fragmentPos;       // Contains the fragment world position in VIEW_SPACE
    
    varying vec2          fragmentUV;
    varying vec4      fragmentNormal;
    
    varying vec4             vLight1;
    varying vec4             vLight2;       // Obsolete very soon
    
    
    
    void main(void) 
    {
        
        
        // Compute light 1
        vec3 pixelToLight        = vec3(vLight1) - vec3(fragmentPos);    // Vector from pixel to light source
        vec3 lightVector         = normalize( pixelToLight );
        float dist2Light         = length( pixelToLight );
         
        float cosAngle           = dot( lightVector , vec3( fragmentNormal ) ); 
              cosAngle           = clamp( cosAngle, 0.0, 1.0 );
        
        float constant_Term      = 0.5;
        float linear_Term        = 0.010;
        float quadratic_Term     = 0.00005;
        
        float attenuation        = 1.0 / (constant_Term + dist2Light*linear_Term + dist2Light*dist2Light*quadratic_Term); //100.0 / dist2Light;
        float final_Multiplier   = cosAngle * attenuation;
        
        
        vec4 color             = texture2D( texSampler, vec2(fragmentUV.s, fragmentUV.t));   // Diffuse
        
        color.r = clamp( ( color.r * final_Multiplier), 0.01, 1.0 ); ;
        color.g = clamp( ( color.g * final_Multiplier), 0.02, 1.0 ); ;
        color.b = clamp( ( color.b * final_Multiplier), 0.04, 1.0 ); ;
       
        
        gl_FragColor = color;
        // gl_FragColor = texture2D( texSampler, vec2(fragmentUV.s, fragmentUV.t));
    }
</script>














<script id="HAX_VS" type="x-shader/x-vertex">
      
    uniform mat4 worldViewMatrix;
    uniform mat4 projMatrix;
    uniform mat4 worldMatrix;
        
    uniform vec3 lights[12];     
        
    attribute vec3  vertexPos;
    attribute vec3  vertexNormal;
    attribute vec2   vertexUV;
    
    varying vec2      fragmentUV;
    varying vec3  fragmentNormal;
     
    void main(void) 
    {
        fragmentUV    = vertexUV;
        gl_Position   = worldViewMatrix * vec4(vertexPos, 1.0);
       
    }
   
</script>



<script id="COLOR_PS" type="x-shader/x-fragment">
    
    precision mediump           float;
    
    varying vec2           fragmentUV;
    varying vec3       fragmentNormal;

    uniform sampler2D      texSampler;
    uniform  vec4              vColor;
    
    
    
    void main(void) 
    {
        vec4 texel = texture2D( texSampler, vec2(fragmentUV.s, fragmentUV.t));
      
        if( texel.r == 1.0 && texel.g == 0.0 && texel.b == 1.0 ) discard;
     
        gl_FragColor = vColor;//vec4( 1.0,0.0,0.0,1.0);
    }
</script>








<script type="text/javascript">

    var renderer   = null;    
    var myCamera   = null;
    var myScene    = null;


 
    
    
      
    function tick() 
    {   
        requestAnimFrame(tick);
          
        if( key_Down( 37 ) )   myCamera.yaw( -0.05  );
        if( key_Down( 39 ) )   myCamera.yaw(  0.05 );
          
        if( key_Down( 38 ) )   myCamera.forward(  1.0 );  
        if( key_Down( 40 ) )   myCamera.backward( 1.0 );

        if( key_Down( 33 ) )   myCamera.move([0,1,0]);
        if( key_Down( 34 ) )   myCamera.move([0,-1,0]);
         
        if(  key_Down( 87 ) )   myCamera.pitch( 0.008 );        // W to pitch up
        if(  key_Down( 83 ) )   myCamera.pitch( -0.008 );      // S to pitch down
         
        if(  key_Down( 81 ) )   myCamera.roll( 0.008 );       // Q to roll left
        if(  key_Down( 69 ) )   myCamera.roll( -0.008 );      // E to roll right
         
        myScene.render();
    }
    
       
    function Map_To_Screen( renderer , hPoint )
    {
       var w2 = renderer.target_Width  / 2;
       var h2 = renderer.target_Height / 2;
       var x  =  ( hPoint[0] - w2  )   / w2;
       var y  =  (  h2 - hPoint[1] )   / h2; 
       return [x,y,0];
    }
    
       
    function register_Inputs()
    {
        document.onkeydown = kbDown_Event;
        document.onkeyup   = kbUp_Event; 
    }
       

    
 
    function Start() 
    {
       var canvas          = document.getElementById("Canvas");
       renderer            = new Renderer( canvas );
       var assman          = new Assetmanager( renderer );
       myScene             = new Scene( renderer, assman, "data/TestLevel/Test.irr" ); 
        
       register_Inputs();      // Erillinen luokka tälle!
      
       var guiTex          = assman.get    ( "data/crosshair1.png", function( renderer, path ) { return new  Texture( renderer.gl ,  path, "FILTER_PLAIN"  ); }); 
       var guiShader       = new   Shader  ( renderer.gl , "HAX_VS"          , "COLOR_PS"                );
       var guiMaterial     = new Material  ( guiShader   , guiTex                                        );
       var c1              = test_Rectangle( renderer.gl , guiMaterial       , [0.05,0.05]  , [1,1,1,1]  );
       var gob1            = new Guiobject (          c1 , [0.0,1.0,0.0,1.0] , 1.0                       );
       myCamera            = new   Camera( renderer, 0.1, 1000, 65        );
       
       myCamera.set_Position(  [-2.750824,0.444516,-24.011581] );
       
       myScene.insert( myCamera      , "CAM"       );
       myScene.insert( gob1          , "GUI"       );
    
       renderer.set_BgrColor( [0.0,0.0,0.0,1.0] );
       
       
    tick();   
    
    }

    
</script>




</head>



<body onload="Start();">
   
    <canvas id="Canvas" style="border: none;" width="1000" height="1000"></canvas>

    <br/>  
</body>

</html>
